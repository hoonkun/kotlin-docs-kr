Kotlin 에서는, 잘 지어진 이름을 가진 함수와 [수신자를 갖는 함수 리터럴](/docs/lambdas.md#수신자를-갖는-함수-리터럴) 을 사용하면,
안전한, 정적 타입을 가지는 빌더를 만들 수 있습니다. 

타입이 안정적인 빌더들은 Kotlin 기반의 도메인 특화 언어(DSL)를 만들 수 있게 하며, 이들은 복잡한 계층적
데이터 구조를 선언적인 형태로 작성하기에 적합합니다. 빌더의 예시 사용 케이스들은 아래와 같습니다:

- [HTML](https://github.com/Kotlin/kotlinx.html) 이나 XML 등의 마크업을 Kotlin 으로 생성하기
- 서버의 라우팅을 정의하기: [Ktor](https://ktor.io/docs/server-routing.html)

아래의 예제를 살펴봅시다:

```kotlin
import com.example.html.* // see declarations below

fun result() =
    html {
        head {
            title {+"XML encoding with Kotlin"}
        }
        body {
            h1 {+"XML encoding with Kotlin"}
            p  {+"this format can be used as an alternative markup to XML"}

            // an element with attributes and text content
            a(href = "https://kotlinlang.org") {+"Kotlin"}

            // mixed content
            p {
                +"This is some"
                b {+"mixed"}
                +"text. For more see the"
                a(href = "https://kotlinlang.org") {+"Kotlin"}
                +"project"
            }
            p {+"some text"}

            // content generated by
            p {
                for (arg in args)
                    +arg
            }
        }
    }
```

이 코드는 완전히 정당한 Kotlin 코드입니다. [여기에서 이 코드로 이것저것 가지고 놀아볼 수 있습니다(브라우저에서 수정하거나 실행할 수도 있습니다!)](https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder).

## 어떻게 동작하나요?

Kotlin 에서 타입이 안정적인 빌더를 구현하려고 한다고 생각해봅시다. 첫 번째로, 만드려는 모델의 구조를 정의해야합니다.
이 경우에는 HTML 태그들을 만들어야겠지요. 이것은 몇 개의 클래스들로 쉽게 가능합니다.
예를 들어, `HTML` 클래스가 그의 자식들 `<head>` 와 `<body>` 를 가지는 `<html>` 태그를 정의합니다.
([아래쪽](#com.example.html-패키지의-전체-코드)의 선언을 살펴보세요.)

이제, 우리가 어째서 아래와 같은 코드를 작성할 수 있는지 살펴볼까요:

```kotlin
html {
 // ...
}
```

`html` 은 사실 [람다 표현](/docs/lambdas.md#람다-표현-문법)을 파라미터로 받는 함수입니다.
이 함수는 아래처럼 정의되어있습니다:

```kotlin
fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
```

이 함수는 하나의 `init` 이라고 명명되는, 그 자체로 함수인 파라미터를 받습니다.
이 함수의 타입은 `HTML.() -> Unit`으로, **수신자를 가지는 함수**입니다.
이는 `HTML` 타입의 인스턴스(**수신자**)를 함수에 전달해야하며, 그 함수 안에서 `HTML` 타입의 멤버를 사용할 수 있음을 의미합니다.

수신자는 `this` 라는 키워드를 통해 접근할 수 있습니다:

```kotlin
html {
    this.head { ... }
    this.body { ... }
}
```

(`head` 와 `body` 는 `HTML` 의 멤버 함수입니다.)

이제, `this` 는 알고 있듯이 생략할 수 있습니다. 그러고 나면 벌써 생각했던 빌더의 모습과 거의 유사한 무언가가 나옵니다:

```kotlin
html {
    head { ... }
    body { ... }
}
```

그래서, 이 호출들이 뭘 할까요? 위에 있는 `html` 함수의 내용을 살펴봅시다. 
우선 `HTML` 타입의 인스턴스를 만들고, 전달받은 함수를 사용하여 초기화한 뒤(이 경우에는 `HTML` 인스턴스의 `head` 와 `body` 함수를 호출합니다), 그 자신을 다시 리턴합니다.
이것이 정확히 빌더들이 해야하는 일입니다.

`HTML` 의 멤버인 `head` 와 `body` 함수들도 `html` 함수와 비슷하게 정의됩니다.
유일한 차이점은 그들 각각이 만든 인스턴스들을 그들을 감싸는 `HTML` 인스턴스의 `children` 컬렉션에 추가한다는 것 정도입니다:

```kotlin
fun head(init: Head.() -> Unit): Head {
    val head = Head()
    head.init()
    children.add(head)
    return head
}

fun body(init: Body.() -> Unit): Body {
    val body = Body()
    body.init()
    children.add(body)
    return body
}
```

이들은 기본적으로 동일한 동작을 하므로, 제너릭을 사용한 `initTag` 를 만들 수도 있습니다:

```kotlin
protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
    tag.init()
    children.add(tag)
    return tag
}
```

이제 이 두 함수들은 매우 간결합니다:

```kotlin
fun head(init: Head.() -> Unit) = initTag(Head(), init)

fun body(init: Body.() -> Unit) = initTag(Body(), init)
```

그리고 이들을 `<head>` 태그와 `<body>` 태그를 만드는데 사용하면 됩니다.

위에서 살펴본 것 중 아직 살펴보지 않은 또 하나의 요소는 태그의 몸체에 어떻게 텍스트를 추가할 수 있을지 입니다.
위의 예제에서 이런 비슷한 코드가 있었지요:

```kotlin
html {
    head {
        title {+"XML encoding with Kotlin"}
    }
    // ...
}
```

즉, 태그의 몸체에 문자열을 곧바로 집어넣었지만, 그 앞에 `+`가 있습니다.
이것은 오버로딩 된 연산자 함수 `unaryPlus()` 를 호출합니다.
이 동작은 `TagWithText` 추상 클래스(`Title`의 슈퍼타입)의 멤버로 정의된, String 을 확장하는 `unaryPlus()` 함수에서 발생합니다.

```kotlin
operator fun String.unaryPlus() {
    children.add(TextElement(this))
}
```

그러므로 여기에서 `+` 접두사가 하는 역할은 문자열들을 `TextElement` 로 감싸 `children` 컬렉션에 추가하는 일입니다.
그럼으로써 이 문자열들이 태그 트리의 일부가 됩니다.

이 모든 내용은 위의 빌더 예제에서 가져온 `com.example.html` 패키지에 정의되어 있습니다. 
이 문서의 마지막 영역에서 이 패키지의 전체 정의를 확인해볼 수 있습니다.

---
{&^---}

`head` 함수는 아래처럼도 작성할 수 있습니다:

```kotlin
fun head(init: Head.() -> Unit) = 
    Head().apply(init).also { children.add(it) }
```

{&$---}

## 스코프 제어: @DslMarker

DSL 을 사용할 때, 어떤 단일 컨텍스트에서 너무 많은 것들이 불릴 수 있는 문제가 발생할 수도 있습니다.
그 컨텍스트의 암시적인 수신자들에 대한 함수를 모두 호출할 수 있습니다. 그렇기 때문에, 위의 예제에서 
`head` 태그 안에서 `head` 를 다시 만드는 등의 정의되지 않은 동작으로 인한 결과를 마주하게 될 수도 있습니다:

```kotlin
html {
    head {
        head {} // 이것은 금지되어야 합니다.
    }
    // ...
}
```

이 예제에서는 가장 가까운 암시적 수신자의 멤버들에만 접근 가능해야합니다. 
`head()` 는 바깥쪽 수신자 `this@html` 의 멤버이므로, 호출이 불가능해야합니다.

이런 문제를 해결하기 위해, 수신자의 스코프를 제어할 수 있는 특별한 메커니즘이 존재합니다.

컴파일러가 스코프를 관리하게 하기 위해서는, DSL에서 수신자들로 사용된 모든 타입들에 같은 마커 어노테이션을 붙혀주면 됩니다.
예를 들어, HTML 빌더들에게는 `@HTMLTagMarker` 를 붙힐 수 있겠지요:

```kotlin
@DslMarker
annotation class HtmlTagMarker
```

어노테이션 클래스는 `@DslMarker` 로 표기되면 DSL 마커로 불리는 특별한 어노테이션이 됩니다.

우리의 DSL 에서 모든 태그들은 슈퍼타입인 `Tag` 를 확장합니다. 
그러므로 슈퍼타입인 `Tag` 클래스에만 `@HtmlTagMarker` 를 붙혀주어도 충분하며 이렇게 하면 Kotlin 의 컴파일러가
모든 확장하는 서브타입들에 대해 어노테이션한 것으로 간주합니다.

```kotlin
@HtmlTagMarker
abstract class Tag(val name: String) { ... }
```

`HTML` 클래스나 `Head` 클래스 등은 이미 그들의 슈퍼타입이 어노테이션 되었으므로 `@HtmlTagMarker` 로 어노테이션할 필요가 없습니다.

```kotlin
class HTML() : Tag("html") { ... }

class Head() : Tag("head") { ... }
```

어노테이션을 추가하고 나면, Kotlin 의 컴파일러가 같은 DSL 의 암시적 수신자가 누구인지 명확하게 알게 되며 
가장 가까운 수신자의 멤버만 호출할 수 있도록 허가합니다:

```kotlin
html {
    head {
        head { } // error: a member of outer receiver
    }
    // ...
}
```

그러나 여전히 바깥쪽 수신자의 멤버를 호출하는 것이 가능하기는 합니다. 
그렇게 하려면 아래처럼 수신자를 명시적으로 지정해주면 됩니다:

```kotlin
html {
    head {
        this@html.head { } // 가능합니다.
    }
    // ...
}
```

## com.example.html 패키지의 전체 코드

아래가 `com.example.html` 패키지의 전체 내용입니다(위의 예제에서 쓰인 요소들만 포함되어있습니다).
이들은 `HTML` 트리를 구성하며, 굉장히 많은 [](/docs/extensions.md)과 [수신자를 가지는 람다](/docs/lambdas.md#수신자를-갖는-함수-리터럴)들을 사용하고 있습니다.

```kotlin
package com.example.html

interface Element {
    fun render(builder: StringBuilder, indent: String)
}

class TextElement(val text: String) : Element {
    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent$text\n")
    }
}

@DslMarker
annotation class HtmlTagMarker

@HtmlTagMarker
abstract class Tag(val name: String) : Element {
    val children = arrayListOf<Element>()
    val attributes = hashMapOf<String, String>()

    protected fun <T : Element> initTag(tag: T, init: T.() -> Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    override fun render(builder: StringBuilder, indent: String) {
        builder.append("$indent<$name${renderAttributes()}>\n")
        for (c in children) {
            c.render(builder, indent + "  ")
        }
        builder.append("$indent</$name>\n")
    }

    private fun renderAttributes(): String {
        val builder = StringBuilder()
        for ((attr, value) in attributes) {
            builder.append(" $attr=\"$value\"")
        }
        return builder.toString()
    }

    override fun toString(): String {
        val builder = StringBuilder()
        render(builder, "")
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML : TagWithText("html") {
    fun head(init: Head.() -> Unit) = initTag(Head(), init)

    fun body(init: Body.() -> Unit) = initTag(Body(), init)
}

class Head : TagWithText("head") {
    fun title(init: Title.() -> Unit) = initTag(Title(), init)
}

class Title : TagWithText("title")

abstract class BodyTag(name: String) : TagWithText(name) {
    fun b(init: B.() -> Unit) = initTag(B(), init)
    fun p(init: P.() -> Unit) = initTag(P(), init)
    fun h1(init: H1.() -> Unit) = initTag(H1(), init)
    fun a(href: String, init: A.() -> Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body : BodyTag("body")
class B : BodyTag("b")
class P : BodyTag("p")
class H1 : BodyTag("h1")

class A : BodyTag("a") {
    var href: String
        get() = attributes["href"]!!
        set(value) {
            attributes["href"] = value
        }
}

fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}
```

{&?}
